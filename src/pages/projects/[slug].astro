---
import { getCollection } from "astro:content";
import { Fragment } from "astro/jsx-runtime";
import "../../styles/home.css";
import "../../styles/project-detail.css";
import "../../styles/page-transitions.css";
import Navigation from "../../components/Navigation.astro";
import Footer from "../../components/Footer.astro";

export async function getStaticPaths() {
  const projects = (await getCollection("projects")) as any[];
  return projects
    .map((project) => {
      // Get slug from project - try multiple fallbacks
      let slug = project.slug;
      if (!slug && project.id) {
        // Extract slug from id (e.g., "projects/my-project.md" -> "my-project")
        slug = project.id.split("/").pop()?.replace(/\.md$/, "") || "";
      }
      if (!slug) {
        console.warn("Project missing slug in getStaticPaths:", project);
        return null;
      }
      return {
        params: { slug },
        props: { project },
      };
    })
    .filter(Boolean);
}

interface Props {
  project: any;
}

const { project } = Astro.props;

if (!project) {
  throw new Error("Project is undefined");
}

// With glob loader in Astro 6.0, project has:
// - project.data: frontmatter (already parsed by schema)
// - project.body: markdown content (raw string)
// - project.rendered: pre-rendered content (if available)
let Content;

// First, check if project.rendered exists and has Content
if (
  project.rendered &&
  typeof project.rendered === "object" &&
  project.rendered.Content
) {
  Content = project.rendered.Content;
} else if (project.body) {
  // Render markdown using unified/remark
  const { unified } = await import("unified");
  const remarkParse = (await import("remark-parse")).default;
  const remarkRehype = (await import("remark-rehype")).default;
  const rehypeStringify = (await import("rehype-stringify")).default;

  const processor = unified()
    .use(remarkParse)
    .use(remarkRehype)
    .use(rehypeStringify);

  const result = await processor.process(project.body);
  Content = String(result);
} else {
  throw new Error(
    `Cannot find content in project. Available keys: ${Object.keys(project).join(", ")}`
  );
}
---

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" type="image/portfolio/svg+xml" href="/portfolio/favicon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content={Astro.generator} />
    <title>{project.data.title} - Astro Blog</title>
    <script>
      // Disable browser scroll restoration and ensure page starts at top
      if ("scrollRestoration" in history) {
        history.scrollRestoration = "manual";
      }
      // Immediately scroll to top on page load
      window.scrollTo(0, 0);
    </script>
  </head>
  <body>
    <Navigation />

    <main class="project-detail-page">
      <div class="project-detail-container page-content">
        <div class="project-header-card project-header-animate">
          <h1 class="project-detail-title">{project.data.title}</h1>
          {
            project.data.tags && project.data.tags.length > 0 && (
              <div class="project-detail-tags">
                {project.data.tags.map((tag: string) => (
                  <span class="project-detail-tag">{tag}</span>
                ))}
              </div>
            )
          }
          <div class="project-detail-meta">
            <a href="/portfolio/projects" class="project-back-button"> ‚Üê Back to projects </a>
            <div class="project-detail-meta-info">
              <span class="project-detail-date">{project.data.date}</span>
            </div>
          </div>
        </div>

        <div class="project-content project-content-animate">
          {
            typeof Content === "function" ? (
              <Content />
            ) : (
              <div set:html={Content} />
            )
          }
        </div>
      </div>
    </main>

    <Footer />

    <script>
      // Ensure scroll position is at top after DOM loads
      document.addEventListener("DOMContentLoaded", () => {
        window.scrollTo(0, 0);
        setTimeout(() => {
          window.scrollTo(0, 0);
        }, 0);
      });
      // Also ensure on page show (handles back/forward navigation)
      window.addEventListener("pageshow", (event) => {
        if (event.persisted) {
          window.scrollTo(0, 0);
        }
      });

      // Initialize page transition animations
      document.addEventListener("DOMContentLoaded", () => {
        // Trigger page content animation
        const pageContent = document.querySelector(".page-content");
        if (pageContent) {
          requestAnimationFrame(() => {
            pageContent.classList.add("visible");
          });
        }

        // Trigger header animation
        const header = document.querySelector(".project-header-animate");
        if (header) {
          requestAnimationFrame(() => {
            header.classList.add("visible");
          });
        }

        // Trigger content animation
        const content = document.querySelector(".project-content-animate");
        if (content) {
          requestAnimationFrame(() => {
            content.classList.add("visible");
          });
        }

        // Apply heading spacing using CSS variables - elegant implementation
        const applyHeadingSpacing = () => {
          const projectContent = document.querySelector(".project-content");
          if (!projectContent) return;

          const rootStyles = getComputedStyle(document.documentElement);
          const getCSSVar = (name: string, fallback: string) =>
            rootStyles.getPropertyValue(name).trim() || fallback;

          // Heading configuration - centralized and maintainable
          const headingConfig = [
            {
              selector: "h2",
              marginTopVar: "--project-h2-margin-top",
              marginBottomVar: "--project-h2-margin-bottom",
              contentMarginTopVar: "--project-h2-content-margin-top",
              defaults: {
                marginTop: "3rem",
                marginBottom: "1.17rem",
                contentMarginTop: "1.17rem",
              },
              skipFirstMarginTop: true,
            },
            {
              selector: "h3",
              marginTopVar: "--project-h3-margin-top",
              marginBottomVar: "--project-h3-margin-bottom",
              contentMarginTopVar: "--project-h3-content-margin-top",
              defaults: {
                marginTop: "2.5rem",
                marginBottom: "1rem",
                contentMarginTop: "1rem",
              },
              skipFirstMarginTop: false,
            },
            {
              selector: "h4",
              marginTopVar: "--project-h4-margin-top",
              marginBottomVar: "--project-h4-margin-bottom",
              contentMarginTopVar: "--project-h4-content-margin-top",
              defaults: {
                marginTop: "2rem",
                marginBottom: "0.83rem",
                contentMarginTop: "0.83rem",
              },
              skipFirstMarginTop: false,
            },
          ];

          const contentTags = ["P", "UL", "OL", "PRE"];

          // Process each heading type using configuration
          headingConfig.forEach((config) => {
            const headings = projectContent.querySelectorAll(config.selector);
            const marginTop = getCSSVar(
              config.marginTopVar,
              config.defaults.marginTop
            );
            const marginBottom = getCSSVar(
              config.marginBottomVar,
              config.defaults.marginBottom
            );
            const contentMarginTop = getCSSVar(
              config.contentMarginTopVar,
              config.defaults.contentMarginTop
            );

            headings.forEach((heading) => {
              if (!(heading instanceof HTMLElement)) return;

              // Apply heading margins
              if (
                config.skipFirstMarginTop &&
                heading.previousElementSibling === null
              ) {
                heading.style.marginTop = "0";
              } else {
                heading.style.marginTop = marginTop;
              }
              heading.style.marginBottom = marginBottom;

              // Apply content spacing after heading
              const nextElement = heading.nextElementSibling;
              if (
                nextElement instanceof HTMLElement &&
                contentTags.includes(nextElement.tagName)
              ) {
                nextElement.style.marginTop = contentMarginTop;
              }
            });
          });
        };

        // Override code block inline styles - use function to run multiple times
        const overrideCodeStyles = () => {
          const codeBlocks = document.querySelectorAll(
            ".project-content pre, .project-content pre.astro-code"
          );
          codeBlocks.forEach((pre) => {
            if (pre instanceof HTMLElement) {
              // Remove inline styles first, then set new ones
              pre.style.removeProperty("background-color");
              pre.style.removeProperty("color");
              pre.style.backgroundColor = "#f5f5f5";
              pre.style.borderRadius = "8px";
              pre.style.color = "#333";

              // Override code element styles
              const code = pre.querySelector("code");
              if (code instanceof HTMLElement) {
                code.style.removeProperty("background-color");
                code.style.removeProperty("color");
                code.style.backgroundColor = "transparent";
                code.style.color = "#333";

                // Override all span styles inside code
                const spans = code.querySelectorAll("span");
                spans.forEach((span) => {
                  if (span instanceof HTMLElement) {
                    span.style.removeProperty("color");
                    span.style.color = "#333";
                  }
                });
              }
            }
          });
        };

        // Run immediately
        applyHeadingSpacing();
        overrideCodeStyles();

        // Also run after delays to catch any late-rendered elements
        setTimeout(() => {
          applyHeadingSpacing();
          overrideCodeStyles();
        }, 100);
        setTimeout(() => {
          applyHeadingSpacing();
          overrideCodeStyles();
        }, 500);
      });
    </script>
  </body>
</html>
